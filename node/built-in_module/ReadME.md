노드는 자바스크립트보다 더 많은 기능을 제공한다. 운영체제 정보에도 접근할 수 있고, 클라이언트가 요청한 주소에 대한 정보도 가져올 수 있다.

## OS

웹 브라우저에 사용되는 자바스크립트는 운영체제의 정보를 가져올 수 없지만, 노드는 os 모듈에 정보가 담겨 있어 정보를 가져올 수 있다.
일반적인 웹 서비스를 제작할 때는 사용 빈도가 높지 않지만, 운영체제별로 다른 서비스를 제공할 때 유용하게 사용될 것이다.

os.arch() : process.arch와 동일하다.
os.platform() : process.platform과 동일하다.
os.type() : 운영체제의 종류
os.uptime() : 운영체제 부팅 이후 흐른 시간(초)
os.hostname() : 컴퓨터의 이름
os.release() : 운영체제의 버전
os.homedir() : 홈 디렉터리 경로
os.tmpdir() : 임시 파일 저장 경로
os.cpus() : 컴퓨터의 코어 정보
os.freemem() : 사용 가능한 메모리(RAM)
os.totalmem() : 전체 메모리 용량

## path

폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈.
운영체제별로 경로 구분자가 다르다.

-> 윈도 : C:\Users\Inhwan처럼 \(백슬래쉬)로 구분
-> 리눅스(POSIX) : /home/Inhwan처럼 /(슬래쉬)로 구분

이러한 경우 등 폴더와 파일 경로를 조작할 때 유용하게 사용할 수 있는 모듈이다.

path.sep : 경로 구분자. 윈도는 \, POSIX는 /
path.delimiter : 환경 변수 구분자. 윈도는 ;, POSIX는 :
path.dirname(경로) : 파일이 위치한 폴더 경로
path.extname(경로) : 파일의 확장자
path.basename(경로, 확장자) : 파일의 이름(확장자 포함) 표시, 파일의 이름만 표시하고 싶다면 basename의 두 번째 인수로 파일 확장자를 넣으면 된다.
path.parse(경로) : 파일 경로를 root, dir, base, ext, name으로 분리한다.
path.format(객체) : path.parse()한 객체를 파일 경로로 합친다.
path.normalize(경로) : /나 \를 실수로 여러 번 사용했거나 혼용했을 때 정상적인 경로로 변환한다.
path.isAbsolute(경로) : 파일의 경로가 절대경로인지 상대경로인지를 true나 false로 반환
path.relative(기준경로, 비교경로) : 경로를 두 개 넣으면 첫 번째 경로에서 두 번째 경로로 가는 방법을 알려준다.
path.join(경로, ...) : 여러 인수를 넣으면 하나의 경로로 합친다. 상대경로인 ..(부모 디렉터리)와 .(현 위치)도 알아서 처리한다.
path.resolve(경로, ...) : path.join()과 비슷하지만 /를 만나면 path.resolve는 절대 경로로 인식해서 앞의 경로를 무시하며, path.join은 상대경로로 처리한다.

## url

Node에서 제공하는 url 모듈은 인터넷 주소를 쉽게 조작하도록 도와주는 모듈이다.
url 처리에는 노드 버전 7에서 추가된 WHATWG(웹 표준을 정하는 단체 이름) 방식의 url과, 예전부터 노드에서 사용하던 구 방식의 url 2가지가 존재한다.
요즘은 WHATWG 방식만 사용하며, 브라우저에서도 WHATWG 방식을 사용하므로 호환성이 좋다.

getAll(키) : 키에 해당하는 모든 값을 가져온다.
get(키) : 키에 해당하는 첫 번째 값만 가져온다.
has(키) : 해당 키의 존재 유무를 검사한다.
keys() : searchParams의 모든 키를 반복기(Iterator 객체)(ES2015 문법)객체로 가져온다.
values() : searchParams의 모든 값을 반복기 객체로 가져온다.
append(키, 값) : 해당 키를 추가한다. 같은 키의 값이 있다면 유지하고 하나 더 추가한다.
set(키, 값) : append와 비슷하지만 같은 키의 값들을 모두 지우고 새로 추가한다.
delete(키) : 해당 키를 제거한다.
toString() : 조작한 searchParams 객체를 다시 문자열로 만든다. 이 문자열을 search에 대입하면 주소 객체에 반영된다.

## dns

DNS를 다룰 때 사용하는 모듈이다. 주로 도메인을 통해 IP나 기타 DNS 정보를 얻고자 할 때 사용한다.

## crypto

다양한 방식의 암호화를 도와주는 모듈이다.

#### 단방향 암호화

비밀번호는 보통 단방향 암호화 알고리즘을 사용해서 암호화한다. 단방향 암호화란 복호화할 수 없는 암호화 방식을 뜻한다.
복호화할 수 없으므로 해시 함수라고 부르기도 한다.

Hash 기법 : 어떠한 문자열을 고정된 길이의 다른 문자열로 바꾸는 방법

createHash(알고리즘) : 사용할 해시 알고리즘을 넣는다. md5, sha1, sha256, sha512 등이 가능하지만, md5와 sha1은 이미 취약점이 발견되었다. 현재는 sha512 정도로 충분하지만, 나중에 sha512도 취약점이 발견된다면 더 강화된 알고리즘으로 바꾸어야 한다.
update(문자열) : 변환할 문자열을 넣는다.
digest(인코딩) : 인코딩할 알고리즘을 넣는다. base64, hex, latin1이 주로 사용되는데, 그중 base64가 결과 문자열이 가장 짧아서 애용된다. 결과물로 변환된 문자열을 반환한다.

sha512보다 더 강력한 sha3도 있다.
현재는 주로 pbkdf2나 bcrypt, scrypt라는 알고리즘으로 비밀번호를 암호화하고 있다. pbkdf2는 노드에서 지원하고 있으며, 기존 문자열에 salt라고 불리는 문자열을 붙인 후 해시 알고리즘을 반복해서 적용하는 방법이다.

crypto.randoBytes와 crypto.pbkdf2 메서드는 내부적으로 스레드 풀을 사용해 멀티 스레딩으로 동작하기 때문에 싱글 스레드 프로그래밍으로 인한 블로킹 걱정은 하지 않아도 된다.

#### 양방향 암호화

양방향 대칭형 암호화는 암호화된 문자열을 복호화할 수 있으며, 키(열쇠)라는 것이 사용된다. 대칭형 암호화에서는 암호를 복호화하려면 암호화할 때 사용한 키와 같은 키를 사용해야 한다.

crypto.createCipheriv(알고리즘, 키, iv) : 암호화 알고리즘과 키, iv를 넣는다. 암호화 알고리즘은 aes-256-cbc를 사용했으며, aes-256-cbc알고리즘의 경우 키는 32바이트여야 하며, iv는 16바이트여야 한다. iv는 암호화할 때 사용하는 초기화 벡터이다. 이 외 사용 가능한 알고리즘 목록은 crypto.getCiphers()를 호출하면 볼 수 있다.
cipher.update(문자열, 인코딩, 출력 인코딩) : 암호화할 대상과 대상의 인코딩, 출력 결과물의 인코딩을 넣는다. 보통 문자열은 utf8 인코딩, 암호는 base64를 많이 사용한다.
cipher.final(출력 인코딩) : 출력 결과물의 인코딩을 넣으면 암호화가 완료된다.
crypto.createDecipheriv(알고리즘, 키, iv) : 복호화할 때 사용된다. 암호화할 때 사용한 값을 그대로 넣어줘야 한다.
decipher.update(문자열, 인코딩, 출력 인코딩) : 암호화된 문장, 그 문장의 인코딩, 복호화할 인코딩을 넣는다. createCipheriv의 update()에서 utf8, base64 순으로 넣었다면 createDecipheriv의 update()에서는 base64, utf8 순으로 넣어야 한다.
decipher.final(출력 인코딩) : 복호화 결과물의 인코딩을 넣는다.

## util

각종 편의 기능을 모아둔 모듈. 

util.deprecate : 함수가 deprecated 처리 되었음을 알림. 함수가 조만간 사라지거나 변경될 때 알려줄 수 있음.
util.promisify : 콜백 패턴을 프로미스 패턴으로 바꿈. 바꿀 함수를 인수로 제공하면 되며, 이렇게 바꿔두면 async/await 패턴까지 사용할 수 있다.

## worker_threads

노드는 싱글 스레드지만 worker_threads를 이용하면 멀티 스레드 방식으로 작업을 처리할 수 있다.
하지만 멀티 스레딩은 기존의 코드보다 훨씬 복잡해진다는 단점도 존재한다.
어떠한 일은 공유하고 있는 데이터가 많아 일을 나누기 어려워진다.
스레드를 여덟 개 사용했다고 해서 작업 속도가 여덟 배 빨라지는 것은 아니다. 스레드를 생성하고 스레드 사이에서 통신하는 데 상당한 비용이 발생하므로 잘못하면 멀티 스레딩을 할 때 싱글 스레딩보다 더 느려지는 현상도 발생할 수 있다.

## child_process

노드에서 다른 프로그램을 실행하거나 명령어를 수행하고 싶을 때 사용하는 모듈이다. 파이썬과 같이 다른 언어의 코드를 실행하고 결과값을 받을 수 있다.
이때 현재 노드 프로세스 외에 새로운 프로세스(자식 프로세스)를 띄워서 명령을 수행하고 노드 프로세스에 결과를 알려주는 방식이기 때문에 child_process라고 한다.

exec는 셸을 실행해서 명령어를 수행하고, spawn은 새로운 프로세스를 띄우면서 명령어를 수행한다. spawn에서도 세 번째 인수로 { shell: true }를 전달하면, exec 처럼 셸을 실행해서 명령어를 수행한다. 셸을 실행하는지 여부에 따라 수행할 수 있는 명령어의 차이가 존재한다.

## 기타 모듈들
async_hooks : 비동기 코드의 흐름을 추적할 수 있는 실험적인 모듈
dgram : UDP와 관련된 작업을 할 때 사용한다.
net : HTTP보다 로우 레벨인 TCP나 IPC 통신을 할 때 사용한다.
perf_hooks : 성능 측정을 할 때 console.time보다 더 정교하게 측정한다.
querystring : URLSearchParams가 나오기 이전에 쿼리스트링을 다루기 위해 사용했던 모듈. 요즘은 URLSearchParams를 사용하는 것을 권장.
string_decoder : 버퍼 데이터를 문자열로 바꾸는 데 사용.
tls : TLS와 SSL에 관련된 작업을 할 때 사용.
v8 : v8 엔진에 직접 접근할 때 사용.
vm : 가상 머신에 직접 접근할 때 사용.
wasi : 웹어셈블리를 실행할 때 사용하는 실험적인 모듈