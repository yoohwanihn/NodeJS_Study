# fs (파일 시스템 접근하기)

fs 모듈은 파일 시스템에 접근하는 모듈이다. 파일을 생성하거나 삭제하고, 읽거나 쓸 수 있도록 하고 폴더도 만들거나 지울 수 있도록 한다.<br>
웹 브라우저에서 자바스크립트를 사용할 때는 일부를 제외하고는 파일 시스템 접근이 금지되어 있으므로 노드의 fs 모듈이 낯설 것이다.<br>


## read_write (파일 읽기 쓰기)

fs 모듈을 불러온 뒤 읽거나 수정할 파일의 경로는 현재 파일 기준이 아니라 node 명령어를 실행하는 콘솔 기준으로 지정해주어야 한다.<br>
fs는 기본적으로 콜백 형식의 모듈이므로 실무에서는 프로미스 형식으로 바꿔주는 방법을 주로 사용할 것이다.<br>

## synchronous_asynchronous (동기 메서드와 비동기 메서드)
-> 동기와 비동기 : 백그라운드 작업 완료 확인 여부<br>
-> 블로킹과 논블로킹 : 함수가 바로 return되는지 여부<br>

setTimeout 같은 타이머와 process.nextTick 외에도, 노드는 대부분 메서드를 비동기 방식으로 처리한다. 하지만 몇몇 메서드는 동기 방식으로도 사용할 수 있다. 특히 fs 모듈이 그러한 메서드를 많이 갖고 있다.<br>

비동기 메서드는 백그라운드에 요청만 하고 다음 작업으로 넘어간다. 그리고 백그라운드 작업이 끝나면 다시 메인 스레드에 알리면 메인 스레드는 그제서야 등록된 콜백 함수를 실행한다. 수백 개의 I/O 요청이 들어와도 메인 스레드는 백그라운드에 요청 처리를 위임하며, 그 후로도 얼마든지 요청을 더 받을 수 있다.<br>

동기 메서드는 요청 작업을 완료한 뒤 그 다음 작업을 진행한다. 그렇기에 요청이 수백 개 이상 들어올 때 성능에 문제가 발생한다. 백그라운드가 작업하는 동안 메인 스레드는 아무것도 못하고 대기하고 있어야 하며, 메인 스레드가 일을 하지 않고 노는 시간이 생기므로 비효율적이다. 백그라운드는 fs 작업을 동시에 처리할 수도 있는데, Sync(동기) 메서드를 사용하면 백그라운드조차 동시에 처리할 수 없게 된다. 따라서 프로그램을 처음 실행할 때 초기화 용도로만 사용하는 것을 권장한다.<br>

비동기 방식으로 하되 순서를 유지하고 싶다면 비동기 메서드의 콜백 다음에 함수를 넣으면 된다. 그리고 이 '콜백 지옥'은 Promise나 async/await으로 어느 정도 해결할 수 있다.<br>

## buffer_stream (버퍼와 스트림)

파일을 읽거나 쓰는 방식은 버퍼를 이용하거나 스트림을 이용하는 두 가지 방식이 있다. 버퍼링은 영상을 재생할 수 있을 때까지 데이터를 모으는 동작이고, 스트리밍은 송출 컴퓨터에서 시청하는 컴퓨터로 영상 데이터를 조금씩 전송하는 동작이다. 스트리밍하는 과정에서 버퍼링을 할 수도 있다.<br>

#### buffer
노드의 readFile 메서드를 사용할 때 읽었던 파일도 버퍼 형식으로 출력되었다. 노드는 파일을 읽을 때 메모리에 파일 크기만큼 공간을 마련해두며 파일 데이터를 메모리에 저장한 뒤 사용자가 조작할 수 있도록 한다. 이때 메모리에 저장된 데이터가 버퍼이다.<br>

from(문자열) : 문자열을 버퍼로 바꿀 수 있다. length 속성은 버퍼의 크기를 알려주며, 바이트 단위이다.<br>
toString(버퍼) : 버퍼를 다시 문자열로 바꿀 수 있다. 이때 base64 나 hex를 인수로 넣으면 해당 인코딩으로 변환 가능하다.<br>
concat(배열) : 배열 안에 든 버퍼들을 하나로 합친다.<br>
alloc(바이트) : 빈 버퍼를 생성한다. 바이트를 인수로 넣으면 해당 크기의 버퍼가 생성된다.<br>

#### stream
readFile 방식의 버퍼가 편리하긴 하지만 문제점도 있다. 용량이 100MB인 파일을 읽을 때 메모리에 100MB의 버퍼를 만들어야 한다. 이 작업을 동시에 열 개 진행하면 1GB에 해당하는 메모리가 사용된다. 서버처럼 몇 명이 이용할지 모르는 환경에서 메모리 문제가 발생할 수 있다. 또한, 모든 내용을 버퍼에 다 쓴 후에야 다음 동작으로 넘어가므로 파일 읽기, 압축, 파일 쓰기 등의 조작을 할 때 매번 전체 용량을 버퍼로 처리해야 다음 단계로 넘어갈 수 있다. 이를 개선하기 위해 버퍼를 1MB로 만든 후 100MB 파일을 100번에 걸쳐 나눠 보내는 스트림 방식이 생겨났다.<br>

#### readStream
createReadStream('문자열', '옵션 객체') : 읽기 스트림을 만든다. 첫 번째 인수로 읽을 파일 경로, 두 번째 인수로 옵션 객체를 넣는다. highWaterMark라는 옵션이 버퍼의 크기를 정할 수 있는 옵션이며, 기본값은 64KB이다.<br>
readStream : 스트림을 읽는다. 이벤트 리스너를 붙여서 사용하며, 보통 data, end, error 이벤트를 사용한다. 파일을 읽는 도중 에러가 발생하면 error 이벤트가 호출되고, 파일 읽기가 시작되면 data 이벤트가 발생한다. 파일을 다 읽으면 end 이벤트가 발생한다.<br><br>
*스트림에서 나눠진 조각을 chunk라고 부른다.

#### writeStream
creatteWriteStream('문자열', '옵션 객체') : 쓰기 스트림을 만든다. 첫 번째 인수로 출력 파일명을 입력하며, 두 번째 인수로 옵션을 입력한다.<br>
writeStream : readStream과 유사하게 스트림을 쓴다. 마찬가지로 이벤트 리스너를 붙여서 사용하며, write 메서드로 데이터를 넣고 end 메서드로 종료를 알린다. 이때 finish 이벤트가 발생한다(콜백).<br>

#### pipe
createReadStream으로 파일을 읽고 그 스트림을 전달받아 createWriteStream으로 파일을 쓸 수도 있는데, 이는 파일 복사와 유사하다. 스트림끼리 연결하는 것을 '파이핑한다' 표현한다.<br>

readStream과 writeStream을 만들어둔 후 두 개의 스트림 사이를 pipe 메서드로 연결하면 따로 on('data')나 writeStream.write를 하지 않아도 알아서 전달된다. 그리고 pipe는 스트림 사이에 여러 번 연결할 수 있다. stream 모듈의 pipeline 메서드를 사용하여 파이프를 연결하면 된다. 중간에 AbortController를 사용해 원할 때 파이프를 중단할 수도 있다.<br><br>


PS C:\Users\USER\Downloads\tteesstt\NodeJS_Study\fs> node buffer-memory<br>
before:  28405760<br>
buffer 1029513216<br>
PS C:\Users\USER\Downloads\tteesstt\NodeJS_Study\fs> node stream-memory<br>
before:  28430336<br>
stream:  56999936<br>

테스트 코드에서 stream 과 buffer의 메모리 차이가 17배 가량 난다.<br>

## etc..(기타 파일 시스템 메서드)

fs.access(경로, 옵션, 콜백) : 폴더나 파일에 접근할 수 있는지를 체크한다. 파일/폴더나 권한이 없다면 에러가 발생하는데, 이때 에러 코드는 ENOENT이다.<br>
fs.mkdir(경로, 콜백) : 폴더를 만드는 메서드이다. 이미 폴더가 있다면 에러가 발생하므로 access 메서드를 호출해서 확인하는 것이 중요하다.<br>
fs.open(경로, 옵션, 콜백) : 파일의 아이디(fd 변수)를 가져오는 메서드이다. 파일이 없다면 파일을 생성한 뒤 그 아이디를 가져온다. 가져온 아이디를 사용해 fs.read 또는 fs.write로 읽거나 쓸 수 있다. 두 번째 인수로 동작을 설정할 수 있다. 쓰려면 w, 읽으려면 r,  기존 파일에 추가하려면 a를 넘겨주면 된다.<br>
fs.rename(기존 경로, 새 경로, 콜백) : 파일의 이름을 바꾸는 메서드이다. 기존 파일 위치와 새로운 파일 위치를 적으면 된다. 잘라내기와 같은 기능을 할 수도 있다.<br>
fs.readdir(경로, 콜백) : 폴더 안의 내용물을 확인할 수 있다. 배열 안에 내부 파일과 폴더명이 나온다.<br>
fs.unlink(경로, 콜백) : 파일을 지울 수 있다. 파일이 없다면 에러가 발생하므로 먼저 파일이 있는지 확인해야 한다.<br>
fs.rmdir(경로, 콜백) : 폴더를 지울 수 있다. 폴더 안에 파일이 있다면 에러가 발생하므로 먼저 내부 파일을 지우고 호출해야 한다.<br>

그리고 노드 8.5버전 이후에는 copyFile 메서드를 사용하면 createReadStream과 createWriteStream을 pipe하지 않아도 파일을 복사할 수 있다.<br>
watch메서드를 활용한다면 내용물을 수정하거나 파일명 변경, 파일 삭제등을 감시할 수 있다. 내용물을 수정하면 change 이벤트가 발생하며, 파일명을 변경하거나 삭제하면 rename이벤트가 발생한다. rename 이벤트가 발생한 후에는 더 이상 watch가 수행되지 않으며, change 이벤트는 두 번씩 발생하기도 하므로 주의가 필요하다.<br>

## threadpool(스레드 풀)

비동기 메서드들은 백그라운드에서 실행되고, 실행된 후에 다시 메인 스레드의 콜백 함수나 프로미스의 then 부분이 실행된다. 이때 fs 메서드를 여러 번 실행해도 백그라운드에서 동시에 처리되는데, 이 이유가 스레드 풀이 존재하기 때문이다.<br>
fs 외에도 내부적으로 스레드 풀을 사용하는 모듈로는, crypto, zlib, dns.lookup 등이 존재한다.<br>
이러한 모듈을 사용하면 실행할 때마다 시간과 순서가 달라지지만 기본적으로 어느정도의 규칙성을 발견할 수 있다. threadpool.js 테스트 코드를 실행하면 1~4, 5~8의 그룹으로 실행 순서가 무작위로 선정되는 것을 알 수 있는데, 이는 기본적으로 스레드 풀이 네 개 이기 때문에 처음 네 개의 작업이 동시에 실행되고 이후의 작업이 실행되기 때문이다. 이 스레드 풀은 컴퓨터의 코어 개수에 따라 다른 결과가 생길 수 있다.<br>